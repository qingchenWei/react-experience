{"version":3,"file":"static/js/Hooks.fa38203c.chunk.js","mappings":"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","sources":["pages/Hooks/index.jsx"],"sourcesContent":["import { Tabs, Button, Input } from \"antd\";\nimport React, {\n  useState,\n  useEffect,\n  useReducer,\n  useContext,\n  createContext,\n  useLayoutEffect,\n  useRef,\n  createRef,\n} from \"react\";\nconst { TabPane } = Tabs;\nconst ReducerContext = createContext(null);\n\nconst useStateCom = () => {\n  const [count, setCount] = useState(0);\n  const addClick = () => {\n    setCount(count + 1);\n  };\n  const subtractClick = () => {\n    setCount(count - 1);\n  };\n  return (\n    <div>\n      <h3>useState</h3>\n      <div>\n        useState是react自带的一个hook函数，它的作用就是用来声明状态变量。useState这个函数接收的参数是我们的状态初始值（initial\n        state），它返回了一个数组，这个数组的第[0]项是当前当前的状态值，第[1]项是可以改变状态值的方法函数\n      </div>\n      <div\n        style={{\n          display: \"flex\",\n          justifyContent: \"center\",\n          alignItems: \"center\",\n        }}\n      >\n        <Button type=\"primary\" onClick={subtractClick}>\n          -\n        </Button>\n        <p style={{ fontSize: \"50px\", margin: \"0 20px\" }}>{count}</p>\n        <Button type=\"primary\" onClick={addClick}>\n          +\n        </Button>\n      </div>\n    </div>\n  );\n};\nconst useEffectCom = () => {\n  const [count, setCount] = useState(0);\n  const [count1, setCount1] = useState(0);\n  useEffect(() => {\n    console.log(\"组件挂载完之后执行,\");\n    // 相当于挂载\n    return () => {\n      //清除副作用\n      //相当于卸载\n    };\n  }, []);\n  useEffect(() => {\n    console.log(\"组件的任何更新触发,\");\n    return () => {\n      //清除副作用\n    };\n  });\n  useEffect(() => {\n    //监听一个\n    console.log(\"count更新触发,\");\n    return () => {\n      //清除副作用\n    };\n  }, [count]);\n  useEffect(() => {\n    //监听一个\n    console.log(\"count和conut1更新触发\", count);\n    return () => {\n      //清除副作用\n    };\n  }, [count, count1]);\n  return (\n    <div>\n      <h3>{count}</h3>\n      <Button type=\"primary\" onClick={() => setCount(count + 1)}>\n        +\n      </Button>\n      <h3>{count1}</h3>\n      <Button type=\"primary\" onClick={() => setCount1(count1 + 1)}>\n        +\n      </Button>\n      <h3>useEffect</h3>\n      <p>副作用钩子：用于处理组件中的副作用，用来取代生命周期函数</p>\n      <p>\n        什么是副作用？<br></br> 副作用 ( side effect ):\n        数据获取，数据订阅，以及手动更改 React 组件中的 DOM 都属于副作用\n        因为我们渲染出的页面都是静态的，任何在其之后的操作都会对他产生影响，所以称之为副作用\n      </p>\n      <div>\n        <h5>依赖参数不同时有不同的效果：</h5>\n        <br></br>为空： 组件的任何更新，该useEffect 对应的返回函数和函数都执行\n        <br></br>为空数组: 不监听组件的更新\n        <br></br>数组中有具体依赖：对应的依赖数据，有变化的时候，才会执行\n      </div>\n    </div>\n  );\n};\nconst useLayoutEffectCom = () => {\n  const [count, setCount] = useState(100);\n  const [count1, setCount1] = useState(100);\n  useEffect(() => {\n    console.log(count, \"1\");\n    if (count === 100000) {\n      setCount(1);\n    }\n  }, [count]);\n  useLayoutEffect(() => {\n    console.log(count1, \"2\");\n    if (count1 === 100000) {\n      setCount1(1);\n    }\n  }, [count1]);\n  return (\n    <div>\n      <h3>useLayoutEffect</h3>\n      <p>\n        1.useEffect会在渲染的内容更新到DOM上后执行,不会阻塞DOM的更新\n        <br />\n        2.useLayoutEffect会在渲染的内容更新到DOM上之前进行,会阻塞DOM的更新(一般不怎么用)\n      </p>\n      <h5>区别:</h5>\n      <h2>{count}</h2>\n      <div>useEffect使用</div>\n      <Button type=\"primary\" onClick={() => setCount(100000)}>\n        变更\n      </Button>\n      <h2>{count1}</h2>\n      <div>useLayoutEffect使用</div>\n      <Button type=\"primary\" onClick={() => setCount1(100000)}>\n        变更\n      </Button>\n    </div>\n  );\n};\n\nconst useReducerCom = () => {\n  /* number为更新后的state值,  dispatchNumbner 为当前的派发函数 */\n  const [number, dispatchNumbner] = useReducer((state, action) => {\n    const { payload, name } = action;\n    /* return的值为新的state */\n    switch (name) {\n      case \"add\":\n        return state + 1;\n      case \"sub\":\n        return state - 1;\n      case \"reset\":\n        return payload;\n      default:\n        return state;\n    }\n  }, 0);\n  const MyChild = (prpos) => {\n    const { dispatch, number } = useContext(ReducerContext);\n    return (\n      <div>\n        <h3>来自父组件(prpos):{prpos.number}</h3>\n        <Button type=\"primary\" onClick={() => dispatch({ name: \"sub\" })}>\n          -\n        </Button>\n        <hr />\n        <h3>来自父组件(useContext):{number}</h3>\n        <p>使用:{`const {(dispatch, number)} = useContext(ReducerContext)`}</p>\n        <Button\n          type=\"primary\"\n          onClick={() => dispatch({ name: \"reset\", payload: 666 })}\n        >\n          reset\n        </Button>\n      </div>\n    );\n  };\n  const MySon = () => {\n    return (\n      <ReducerContext.Consumer>\n        {(value) => (\n          <div>\n            <h3>来自父组件(useContext):{value.number}</h3>\n            <p>\n              使用:{`<ReducerContext.Consumer></ReducerContext.Consumer>`}包裹\n            </p>\n            <Button\n              type=\"primary\"\n              onClick={() => value.dispatch({ name: \"add\" })}\n            >\n              +\n            </Button>\n          </div>\n        )}\n      </ReducerContext.Consumer>\n    );\n  };\n  return (\n    <div>\n      <h3>useReducer</h3>\n      <p>\n        useReducer 是 react-hooks 提供的能够在无状态组件中运行的类似redux的功能\n        api 。\n      </p>\n      <Button type=\"primary\" onClick={() => dispatchNumbner({ name: \"add\" })}>\n        增加\n      </Button>\n      <Button type=\"primary\" onClick={() => dispatchNumbner({ name: \"sub\" })}>\n        减少\n      </Button>\n      <Button\n        type=\"primary\"\n        onClick={() => dispatchNumbner({ name: \"reset\", payload: 666 })}\n      >\n        赋值\n      </Button>\n      {/* 把dispatch 和 state 传递给子组件  */}\n      <div>{number}</div>\n      <ReducerContext.Provider value={{ dispatch: dispatchNumbner, number }}>\n        <MyChild number={number} dispatch={dispatchNumbner}></MyChild>\n        <hr />\n        <MySon></MySon>\n      </ReducerContext.Provider>\n    </div>\n  );\n};\nconst useRefCom = () => {\n  const [count, setCount] = useState(0);\n  const myRef2 = useRef(0);\n  const myRef = useRef(null);\n  const myCreateRef = createRef();\n  // 当 useRef 的内容发生变化时,它不会通知您。\n  // 更改.current属性不会导致重新呈现。因为他一直是一个引用\n  useEffect(() => {\n    console.log(myRef, \"myRef\");\n    myRef?.current?.focus();\n    myRef2.current = count;\n    myCreateRef.current = count;\n\n    console.log(myRef2);\n  });\n  function handleClick() {\n    setTimeout(() => {\n      console.log(count);\n      console.log(myRef2.current);\n    }, 3000);\n  }\n\n  return (\n    <div>\n      <h3>以下分别介绍 useRef 的两个使用场景：</h3>\n      <h5>1、指向 dom 元素</h5>\n      <Input ref={myRef} type=\"text\" />\n      <div>2、存放变量</div>\n      <p>\n        useRef 在 react hook 中的作用, 正如官网说的, 它像一个变量, 类似于 this ,\n        它就像一个盒子, 你可以存放任何东西. createRef\n        每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用\n      </p>\n      <div>\n        <Button onClick={() => setCount(count + 1)}>点击count</Button>\n        <Button onClick={() => handleClick()}>查看</Button>\n      </div>\n    </div>\n  );\n};\n\nfunction App() {\n  const hooks = [\n    {\n      name: \"useState\",\n      component: useStateCom,\n    },\n    {\n      name: \"useEffect\",\n      component: useEffectCom,\n    },\n    {\n      name: \"useLayoutEffect\",\n      component: useLayoutEffectCom,\n    },\n    {\n      name: \"useReducer-useContext\",\n      component: useReducerCom,\n    },\n    {\n      name: \"useRef\",\n      component: useRefCom,\n    },\n  ];\n  const onChange = (key) => {\n    console.log(key);\n  };\n\n  return (\n    <Tabs defaultActiveKey=\"useState\" onChange={onChange}>\n      {hooks.map((item) => {\n        return (\n          <TabPane tab={item.name} key={item.name}>\n            <item.component />\n          </TabPane>\n        );\n      })}\n    </Tabs>\n  );\n}\n\nexport default App;\n"],"names":["TabPane","ReducerContext","createContext","useStateCom","useState","count","setCount","style","display","justifyContent","alignItems","type","onClick","fontSize","margin","useEffectCom","count1","setCount1","useEffect","console","log","useLayoutEffectCom","useLayoutEffect","useReducerCom","useReducer","state","action","payload","name","number","dispatchNumbner","MyChild","prpos","useContext","dispatch","MySon","Consumer","value","Provider","useRefCom","myRef2","useRef","myRef","myCreateRef","createRef","current","focus","ref","setTimeout","hooks","component","defaultActiveKey","onChange","key","map","item","tab"],"sourceRoot":""}